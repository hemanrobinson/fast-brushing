{"version":3,"sources":["Data.js","Axis.js","Plot.js","Matrix.js","App.js","index.js"],"names":["Data","props","isSelected","deselectAll","fill","getColumnNames","getDomain","nData","i","values","getValues","length","f","d3","x","y","Axis","draw","width","height","canvas","index","g","getContext","columnNames","fillStyle","fontSize","s","fillText","measureText","slice","Plot","padding","normalize","rect","nx","ny","nw","nh","isWithin","point","tol","nRect","undefined","j","opacity","imageData","selectedRows","data","xScale","domain","range","yScale","deselectedImageData","d","createImageData","forEach","datum","xScaled","yScaled","k","Math","floor","round","myImageData","set","row","putImageData","select","brush","xMin","invert","min","xMax","max","yMin","yMax","push","Matrix","ref","useRef","nColumns","onMouseUp","event","useEffect","downLocation","type","nativeEvent","offsetX","offsetY","onMouseDown","onMouseMove","handleSize","isGrowing","isXMin","isYMin","isMoving","bitmaps","clear","size","halfSize","xDown","yDown","preventDefault","isXMax","isYMax","abs","xUp","yUp","iEvent","jEvent","iBrush","jBrush","current","clearRect","drawBrush","strokeStyle","moveTo","lineTo","stroke","isFirstDraw","strokeRect","fillRect","App","useState","getPower","setNData","setOpacity","className","href","Slider","defaultValue","step","valueLabelDisplay","marks","valueLabelFormat","value","toExponential","onChangeCommitted","exp","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.8c18cc84.chunk.js","sourcesContent":["import * as d3 from 'd3';\n\n/**\n * Data sets.\n *\n * @param  {Object}  props  properties\n * @return component\n */\nconst Data = ( props ) => {\n};\n\n/**\n * True iff data row is selected.\n *\n * @type {boolean[]}\n */\nData.isSelected = [];\n\n/**\n * Deselects all rows.\n */\nData.deselectAll = () => {\n    Data.isSelected.fill( false );\n};\n\n/**\n * Returns column names.\n *\n * @return {string[]}  column names\n */\nData.getColumnNames = () => {\n    return [ \"isSelected\", \"A\", \"B\", \"A + B\", \"A * B\" ];\n};\n\n/**\n * Returns domain of specified column.\n *\n * @param  {number}    nData  number of data values\n * @param  {number}    index  column index\n * @return {number[]}  domain of specified column\n */\nData.getDomain = ( nData, i ) => {\n//  return [ d3.min( Data.getValues( nData ), d => d[ index ]), d3.max( Data.getValues( nData ), d => d[ index ])];\n    return [ -2, 2 ];   // consistently spreads the data\n};\n\n/**\n * Data values.\n *\n * @type {number[]}\n */\nData.values = [];\n\n/**\n * Returns data values.\n *\n * @param  {number}  nData  number of data values\n * @return {Array[]}  data values by row\n */\nData.getValues = ( nData ) => {\n    if( Data.values.length !== nData ) {\n        let f = d3.randomNormal( 0, 0.5 );\n        Data.values = [];\n        for( let i = 0; ( i < nData ); i++ ) {\n            let x = f(), y = f();\n            Data.values[ i ] = [ false, x, y, x + y, x * y ];\n        }\n    }\n    return Data.values;\n};\n\nexport default Data;\n","import Data from './Data';\n\n/**\n * Axis for scatter plot matrix in an SVG element.\n *\n * @param  {Object}  props  properties\n * @return component\n */\nconst Axis = ( props ) => {\n};\n\n/**\n * Draws the axis.\n *\n * @param  {number}  x        X coordinate, in pixels\n * @param  {number}  y        Y coordinate, in pixels\n * @param  {number}  width    width, in pixels\n * @param  {number}  height   height, in pixels\n * @param  {Element} canvas   CANVAS element\n * @param  {number}  nData    number of data values\n * @param  {number}  index    column index\n */\nAxis.draw = ( x, y, width, height, canvas, nData, index ) => {\n    \n    // Initialization.\n    let g = canvas.getContext( \"2d\" ),\n        columnNames = Data.getColumnNames();\n        \n    // Draw the column label.\n    g.fillStyle = \"#000000\";\n    g.fontSize = \"14px\";\n    let s = columnNames[ index ];\n    g.fillText( s, x + width / 2 - g.measureText( s ).width / 2, y + height - height / 2 + 4 );\n    \n    // Draw the minimum and maximum.\n    g.fontSize = \"10px\";\n    s = ( \"\" + Data.getDomain( nData, index )[ 0 ]).slice( 0, 4 );\n    g.fillText( s, x + 4, y + height - 4 );\n    s = ( \"\" + Data.getDomain( nData, index )[ 1 ]).slice( 0, 3 );\n    g.fillText( s, x + width - 3 - g.measureText( s ).width, y + 12 );\n};\n\nexport default Axis;\n","import * as d3 from 'd3';\nimport Data from './Data';\n\n/**\n * Scatter plot in an SVG element.\n *\n * @param  {Object}  props  properties\n * @return component\n */\nconst Plot = ( props ) => {\n};\n \n/**\n * Padding, in pixels.\n *\n * @constant {number}\n */\nPlot.padding = 10;\n    \n/**\n * Returns normalized rectangle.\n *\n * @param   {Rect}  rect   rectangle\n * @return  {Rect}  normalized rectangle\n */\nPlot.normalize = ( rect ) => {\n    let nx = rect.x,\n        ny = rect.y,\n        nw = rect.width,\n        nh = rect.height;\n    if( nw < 0 ) {\n        nx += nw;\n        nw = -nw;\n    }\n    if( nh < 0 ) {\n        ny += nh;\n        nh = -nh;\n    }\n    return { x: nx, y: ny, width: nw, height: nh };\n}\n\n/**\n * Returns whether point is within rectangle, within tolerance.\n *\n * @param  {Point}   point  point\n * @param  {Rect}    rect   rectangle\n * @param  {number}  tol    tolerance, or 0 for undefined\n */\nPlot.isWithin = ( point, rect, tol ) => {\n    let nRect = Plot.normalize( rect );\n    if( tol !== undefined ) {\n        nRect.x -= tol;\n        nRect.y -= tol;\n        nRect.width += 2 * tol;\n        nRect.height += 2 * tol;\n    }\n    return ( nRect.x <= point.x ) && ( point.x < nRect.x + nRect.width  ) &&\n           ( nRect.y <= point.y ) && ( point.y < nRect.y + nRect.height );\n}\n\n/**\n * Draws the plot.\n *\n * @param  {number}               x             X coordinate, in pixels\n * @param  {number}               y             Y coordinate, in pixels\n * @param  {number}               width         width, in pixels\n * @param  {number}               height        height, in pixels\n * @param  {Element}              canvas        CANVAS element\n * @param  {number}               nData         number of data values\n * @param  {number}               i             X column index\n * @param  {number}               j             Y column index\n * @param  {number}               opacity       alpha\n * @param  {ImageData|undefined}  imageData     bitmap of deselected points, or undefined if none\n * @param  {number[]|undefined}   selectedRows  Array of indices of selected rows, or undefined if none\n * @return {ImageData}            bitmap of deselected points\n */\nPlot.draw = ( x, y, width, height, canvas, nData, i, j, opacity, imageData, selectedRows ) => {\n    \n    // Initialization.\n    const g = canvas.getContext( \"2d\" ),\n        padding = Plot.padding;\n    let data = Data.getValues( nData ),\n        xScale = d3.scaleLinear().domain( Data.getDomain( nData, i )).range([ x + padding, x + width - padding ]),\n        yScale = d3.scaleLinear().domain( Data.getDomain( nData, j )).range([ y + height - padding, y + padding ]),\n        deselectedImageData = imageData;\n        \n    // Create the deselected bitmap if necessary.\n    // For alpha blending, see e.g. https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending.\n    if( deselectedImageData === undefined ) {\n        deselectedImageData = g.createImageData( width, height );                           // black and transparent\n        const d = deselectedImageData.data;\n        data.forEach(( datum ) => {\n            let xScaled = xScale( datum[ i ]) - x,\n                yScaled = yScale( datum[ j ]) - y;\n            if(( 0 <= xScaled ) && ( xScaled < width ) && ( 0 <= yScaled ) && ( yScaled < height )) {\n                let k = Math.floor( yScaled ) * ( width * 4 ) + Math.floor( xScaled ) * 4;\n                d[ k     ] = Math.round(             0 + d[ k     ] * ( 1 - opacity ));     // r\n                d[ k + 1 ] = Math.round(             0 + d[ k + 1 ] * ( 1 - opacity ));     // g\n                d[ k + 2 ] = Math.round(             0 + d[ k + 2 ] * ( 1 - opacity ));     // b\n                d[ k + 3 ] = Math.round( 255 * opacity + d[ k + 3 ] * ( 1 - opacity ));     // alpha\n            }\n        });\n    }\n    \n    // Make a local copy.\n    let myImageData = g.createImageData( width, height );\n    myImageData.data.set( deselectedImageData.data );\n    const d = myImageData.data;\n    \n    // Selected rows use opacity, but not alpha blending, in order to keep them bright.\n    // Add the selected rows as specified...\n    if( selectedRows !== undefined ) {\n        selectedRows.forEach(( row ) => {\n            let xScaled = xScale( data[ row ][ i ]) - x,\n                yScaled = yScale( data[ row ][ j ]) - y;\n            if(( 0 <= xScaled ) && ( xScaled < width ) && ( 0 <= yScaled ) && ( yScaled < height )) {\n                let k = Math.floor( yScaled ) * ( width * 4 ) + Math.floor( xScaled ) * 4;\n                d[ k ] = Math.round( 255 + d[ k ] * ( 1 - opacity ));                       // r\n            }\n        });\n    }\n    \n    // ...or add the selected rows from the data.\n    else {\n        let row = 0;\n        data.forEach(( datum ) => {\n            if( Data.isSelected[ row ]) {\n                let xScaled = xScale( datum[ i ]) - x,\n                    yScaled = yScale( datum[ j ]) - y;\n                if(( 0 <= xScaled ) && ( xScaled < width ) && ( 0 <= yScaled ) && ( yScaled < height )) {\n                    let k = Math.floor( yScaled ) * ( width * 4 ) + Math.floor( xScaled ) * 4;\n                    d[ k ] = Math.round( 255 + d[ k ] * ( 1 - opacity ));                   // r\n                }\n            }\n            row++;\n        });\n    }\n    \n    // Draw and return the bitmap.\n    g.putImageData( myImageData, x, y, padding, padding, width - 2 * padding, height - 2 * padding );\n    return deselectedImageData;\n};\n\n/**\n * Selects rows within the brush and returns them.\n *\n * @param  {number}    x       X coordinate, in pixels\n * @param  {number}    y       Y coordinate, in pixels\n * @param  {number}    width   width, in pixels\n * @param  {number}    height  height, in pixels\n * @param  {number}    nData   number of data values\n * @param  {number}    i       X column index\n * @param  {number}    j       Y column index\n * @param  {Rect}      brush   brush\n * @return {number[]}  Array of indices of selected rows, or undefined if none\n */\nPlot.select = ( x, y, width, height, nData, i, j, brush ) => {\n    \n    // Initialization.\n    const padding = Plot.padding;\n    let selectedRows = [],\n        data = Data.getValues( nData ),\n        xScale = d3.scaleLinear().domain( Data.getDomain( nData, i )).range([ x + padding, x + width - padding ]),\n        yScale = d3.scaleLinear().domain( Data.getDomain( nData, j )).range([ y + height - padding, y + padding ]),\n        xMin = xScale.invert( Math.min( brush.x, brush.x + brush.width )),\n        xMax = xScale.invert( Math.max( brush.x, brush.x + brush.width )),\n        yMin = yScale.invert( Math.max( brush.y, brush.y + brush.height )),\n        yMax = yScale.invert( Math.min( brush.y, brush.y + brush.height ));\n    \n    // Select the rows and return them.\n    let row = 0;\n    data.forEach(( datum ) => {\n        Data.isSelected[ row ] = ( xMin <= datum[ i ]) && ( datum[ i ] < xMax ) && ( yMin <= datum[ j ]) && ( datum[ j ] < yMax );\n        if( Data.isSelected[ row ]) {\n            selectedRows.push( row );\n        }\n        row++;\n    });\n    return selectedRows;\n};\n\nexport default Plot;\n","import React, { useRef, useEffect }  from 'react';\nimport Data from './Data';\nimport Axis from './Axis';\nimport Plot from './Plot';\nimport './Matrix.css';\n\n/**\n * @typedef  Point  point\n *\n * @type  {object}\n * @property  {number}   x        X coordinate, in pixels\n * @property  {number}   y        Y coordinate, in pixels\n */\n\n/**\n * @typedef  Rect  rectangle\n *\n * @type  {object}\n * @property  {number}   x        X coordinate, in pixels\n * @property  {number}   y        Y coordinate, in pixels\n * @property  {number}   width    width, in pixels\n * @property  {number}   height   height, in pixels\n */\n\n/**\n * Scatter plot matrix in an SVG element.\n *\n * @param  {Object}  props  properties\n * @return component\n */\nconst Matrix = ( props ) => {\n    \n    // Initialization.\n    const width = 200, height = 200;\n    let ref = useRef(),\n        { nData, opacity } = props,\n        columnNames = Data.getColumnNames(),\n        nColumns = columnNames.length;\n    \n    // Support mousedown, mousemove, and mouseup events.\n    let onMouseDown = ( event ) => {\n            Matrix.onMouseDown( event );\n        },\n        onMouseUp = ( event ) => {\n            Matrix.onMouseUp( event, width, height, ref, nData, opacity );\n        };\n    \n    // Set hook to select and draw on mounting.\n    useEffect(() => {\n        const brush = Matrix.brush;\n        Matrix.downLocation = { x: brush.x, y: brush.y };\n        const event = { type: \"mouseup\", nativeEvent: { offsetX: brush.x + brush.width, offsetY: brush.y + brush.height }};\n        Matrix.onMouseUp( event, width, height, ref, nData, opacity );\n        Matrix.draw( width, height, ref, nData, opacity );\n    });\n    \n    // Return the component.\n    return <canvas width={( nColumns - 1 ) * width} height={( nColumns - 1 ) * height} ref={ref} onMouseDown={onMouseDown} onMouseMove={onMouseUp} onMouseUp={onMouseUp}></canvas>;\n};\n \n/**\n * Brush handle size.\n *\n * @constant {number}\n */\nMatrix.handleSize = 3;\n \n/**\n * True iff the user is resizing the brush.\n *\n * @type {boolean}\n */\nMatrix.isGrowing = false;\n \n/**\n * True iff the user is resizing the brush with one of the minimum X handles.\n *\n * @type {boolean}\n */\nMatrix.isXMin = false;\n \n/**\n * True iff the user is resizing the brush with one of the minimum Y handles.\n *\n * @type {boolean}\n */\nMatrix.isYMin = false;\n \n/**\n * True iff the user is moving the brush.\n *\n * @type {boolean}\n */\nMatrix.isMoving = false;\n \n/**\n * True iff the user event is within a plot that contains a brush.\n *\n * @type {boolean}\n */\nMatrix.isWithin = false;\n\n/**\n * Bitmaps of deselected rows, cached for optimization.\n *\n * @type {ImageData[][]|undefined}\n */\nMatrix.bitmaps = undefined;\n \n/**\n * Array of indices of selected rows, or undefined if none.\n *\n * @type {number[]|undefined}\n */\nMatrix.selectedRows = undefined;\n \n/**\n * Brush.  If no brush is defined, x and y are less than zero.\n *\n * @type {Rect}\n */\nMatrix.brush = { x: 460, y: 260, width: 40, height: 40 };\n \n/**\n * Down event location.  If no down location is defined, x and y are less than zero.\n *\n * @type {Point}\n */\nMatrix.downLocation = { x: -1, y: -1 };\n \n/**\n * Clears data structures.\n */\nMatrix.clear = () => {\n    Matrix.bitmaps = undefined;\n    Matrix.selectedRows = undefined;\n    Data.deselectAll();\n    Matrix.brush = { x: -1, y: -1, width: 0, height: 0 };\n    Matrix.downLocation = { x: -1, y: -1 };\n};\n    \n/**\n * Handles mouse down event.\n *\n * This method modifies Matrix.downLocation.\n *\n * @param  {Event}    event     event\n */\nMatrix.onMouseDown = ( event ) => {\n\n    // Initialization.\n    const size = Matrix.handleSize,\n        halfSize = size / 2,\n        tol = 2 * size;\n    let xDown = event.nativeEvent.offsetX,\n        yDown = event.nativeEvent.offsetY,\n        brush = Matrix.brush;\n        \n    // Prevent text selection.\n    event.preventDefault();\n        \n    // Reset the mousedown coordinates.\n    Matrix.downLocation.x = xDown;\n    Matrix.downLocation.y = yDown;\n    \n    // If within an existing brush, store the handle...\n    if( Plot.isWithin({ x: xDown, y: yDown }, brush, Matrix.handleSize )) {\n        let isXMin = false,\n            isXMax = false,\n            isYMin = false,\n            isYMax = false;\n        if( brush.width >= 0 ) {\n            if( Math.abs( brush.x + brush.width - halfSize - xDown ) <= tol ) {\n                isXMax = true;\n            } else if( Math.abs( brush.x + halfSize - xDown ) <= tol ) {\n                isXMin = true;\n            }\n        } else {\n            if( Math.abs( brush.x + brush.width + halfSize - xDown ) <= tol ) {\n                isXMin = true;\n            } else if( Math.abs( brush.x - halfSize - xDown ) <= tol ) {\n                isXMax = true;\n            }\n        }\n        if( brush.height >= 0 ) {\n            if( Math.abs( brush.y + brush.height - halfSize - yDown ) <= tol ) {\n                isYMin = true;\n            } else if( Math.abs( brush.y + halfSize - yDown ) <= tol ) {\n                isYMax = true;\n            }\n        } else {\n            if( Math.abs( brush.y + brush.height + halfSize - yDown ) <= tol ) {\n                isYMax = true;\n            } else if( Math.abs( brush.y - halfSize - yDown ) <= tol ) {\n                isYMin = true;\n            }\n        }\n        Matrix.isGrowing = false;\n        Matrix.isMoving = false;\n        if(( isXMin || isXMax ) && ( isYMin || isYMax )) {\n            Matrix.isGrowing = true;\n            Matrix.isXMin = isXMin;\n            Matrix.isYMin = isYMin;\n        } else {\n            Matrix.isMoving = true;\n        }\n    }\n    \n    // ...otherwise start creating a new brush.\n    else {\n        Matrix.brush.x = xDown;\n        Matrix.brush.y = yDown;\n        Matrix.brush.width = 0;\n        Matrix.brush.height = 0;\n        Matrix.isGrowing = true;\n        Matrix.isXMin = false;\n        Matrix.isYMin = true;\n        Matrix.isMoving = false;\n    }\n    \n    // A mousedown event is either within an existing brush, or within a new brush.\n    Matrix.isWithin = true;\n};\n\n/**\n * Handles mouse up event.\n *\n * This method modifies Matrix.downLocation.\n *\n * @param  {Event}   event    event\n * @param  {number}  width    width, in pixels\n * @param  {number}  height   height, in pixels\n * @param  {Object}  ref      reference to SVG element\n * @param  {number}  nData    number of data values\n * @param  {number}  opacity  alpha\n */\nMatrix.onMouseUp = ( event, width, height, ref, nData, opacity ) => {\n\n    // Initialization.\n    let xDown = Matrix.downLocation.x,\n        yDown = Matrix.downLocation.y,\n        xUp = event.nativeEvent.offsetX,\n        yUp = event.nativeEvent.offsetY,\n        i = Math.floor( xDown / width ),\n        j = Math.floor( yDown / height ),\n        x = i * width,\n        y = j * height,\n        brush = Matrix.brush;\n    \n    // If the mouse button is not down, and the brush appearance changed, draw it...\n    if(( xDown < 0 ) || ( yDown < 0 )) {\n        const iEvent = Math.floor( xUp / width ),\n            jEvent = Math.floor( yUp / height ),\n            iBrush = Math.floor( brush.x / width ),\n            jBrush = Math.floor( brush.y / height ),\n            isWithin = ( iEvent === iBrush ) && ( jEvent === jBrush );\n        if( Matrix.isWithin !== isWithin ) {\n            Matrix.isWithin = isWithin;\n        \n            // If handles are being removed, erase and draw only the plot that contains the brush.\n            if( !isWithin ) {\n                let canvas = ref.current,\n                    g = canvas.getContext( \"2d\" ),\n                    x = iBrush * width,\n                    y = jBrush * height;\n                g.clearRect( x + 1, y + 1, width - 1, height - 1 );\n                Plot.draw( x, y, width, height, canvas, nData, iBrush + 1, jBrush + 1, opacity, Matrix.bitmaps[ iBrush ][ jBrush ], Matrix.selectedRows );\n            }\n            \n            // Draw the brush.\n            Matrix.drawBrush( ref );\n        }\n    }\n        \n    // ...or if the event is on an axis, deselect on mouseup...\n    else if( i === j ) {\n        if( event.type === \"mouseup\" ) {\n            Data.deselectAll();\n            Matrix.selectedRows = undefined;\n            Matrix.draw( width, height, ref, nData, opacity );\n        }\n    }\n        \n    // ...or if the event is on a plot, handle brushing.\n    else {\n        \n        // Grow the brush...\n        if( Matrix.isGrowing ) {\n            xUp = Math.min( x + width  - 1, Math.max( x + 1, xUp ));\n            yUp = Math.min( y + height - 1, Math.max( y + 1, yUp ));\n            if( Matrix.isXMin ) {\n                brush.width -= xUp - brush.x;\n                brush.x = xUp;\n            } else {\n                brush.width = xUp - brush.x;\n            }\n            if( Matrix.isYMin ) {\n                brush.height = yUp - brush.y;\n            } else {\n                brush.height -= yUp - brush.y;\n                brush.y = yUp;\n            }\n        }\n        \n        // ...or move the brush.\n        else if( Matrix.isMoving ) {\n            brush.x += xUp - xDown;\n            brush.y += yUp - yDown;\n            Matrix.downLocation.x = xUp;\n            Matrix.downLocation.y = yUp;\n            if( brush.x < x + 1 ) {\n                brush.x = x + 1;\n            }\n            if( brush.x > x + width - 1 - brush.width ) {\n                brush.x = x + width - 1 - brush.width;\n            }\n            if( brush.y < y + 1 ) {\n                brush.y = y + 1;\n            }\n            if( brush.y > y + height - 1 - brush.height ) {\n                brush.y = y + height - 1 - brush.height;\n            }\n        }\n        \n        // Select points within the brush, and deselect all others.\n        Matrix.selectedRows = Plot.select( x, y, width, height, nData, i + 1, j + 1, brush );\n        Matrix.draw( width, height, ref, nData, opacity );\n    }\n    \n    // On mouseup, clear the down location and normalize the brush.\n    if( event.type === \"mouseup\" ) {\n        Matrix.downLocation.x = -1;\n        Matrix.downLocation.y = -1;\n        Matrix.isGrowing = false;\n        Matrix.isXMin = false;\n        Matrix.isYMin = false;\n        Matrix.isMoving = false;\n        if( brush.width < 0 ) {\n            brush.x += brush.width;\n            brush.width = -brush.width;\n        }\n        if( brush.height < 0 ) {\n            brush.y += brush.height;\n            brush.height = -brush.height;\n        }\n    }\n};\n\n/**\n * Draws the plots.\n *\n * @param  {number}  width    width in pixels\n * @param  {number}  height   height in pixels\n * @param  {Array}   ref      reference to SVG element\n * @param  {number}  nData    number of data values\n * @param  {number}  opacity  alpha\n */\nMatrix.draw = ( width, height, ref, nData, opacity ) => {\n    \n    // Initialization.  If no context, do nothing.\n    if( !ref ) {\n        return;\n    }\n    let canvas = ref.current,\n        g = canvas.getContext( \"2d\" ),\n        nColumns = Data.getColumnNames().length;\n    if( !g ) {\n        return;\n    }\n    \n    // Erase the drawing area.\n    g.clearRect( 0, 0, ( nColumns - 1 ) * width, ( nColumns - 1 ) * height );\n    \n    // Draw the grid.\n    g.strokeStyle = \"#a0a0a0\";\n    for( let i = 1; ( i < nColumns - 1 ); i++ ) {\n        g.moveTo( i * width + 0.5, 0 );\n        g.lineTo( i * width + 0.5, ( nColumns - 1 ) * height );\n        g.moveTo( 0, i * height + 0.5 );\n        g.lineTo(( nColumns - 1 ) * width, i * height + 0.5 );\n    }\n    g.stroke();\n    \n    // Draw the plots and the axes.  On first draw, store the bitmaps.\n    let isFirstDraw = !Matrix.bitmaps;\n    if( isFirstDraw ) {\n        Matrix.bitmaps = [];\n    }\n    for( let i = 1; ( i < nColumns ); i++ ) {\n        for( let j = 1; ( j < nColumns ); j++ ) {\n\n            // Get the position.\n            let x = ( i - 1 ) * width,\n                y = ( j - 1 ) * height;\n\n            // Draw an axis...\n            if( i === j ) {\n                Axis.draw( x, y, width, height, canvas, nData, i );\n            }\n\n            // ...or a plot.\n            else {\n                if( isFirstDraw ) {\n                    if( Matrix.bitmaps[ i - 1 ] === undefined ) {\n                        Matrix.bitmaps[ i - 1 ] = [];\n                    }\n                    Matrix.bitmaps[ i - 1 ][ j - 1 ] = Plot.draw( x, y, width, height, canvas, nData, i, j, opacity );\n                } else {\n                    Plot.draw( x, y, width, height, canvas, nData, i, j, opacity, Matrix.bitmaps[ i - 1 ][ j - 1 ], Matrix.selectedRows );\n                }\n            }\n        }\n    }\n    \n    // Draw the brush.\n    Matrix.drawBrush( ref );\n};\n\n/**\n * Draws the brush.\n *\n * @param  {Array}   ref      reference to SVG element\n */\nMatrix.drawBrush = ( ref ) => {\n    let brush = Matrix.brush;\n    if(( brush.x >= 0 ) && ( brush.y >= 0 )) {\n        \n        // Normalize the brush and minimize anti-aliasing.\n        const size = Matrix.handleSize;\n        let nRect = Plot.normalize( brush );\n        nRect.x = Math.floor( nRect.x ) + 0.5;\n        nRect.y = Math.floor( nRect.y ) + 0.5;\n        nRect.width = Math.round( nRect.width );\n        nRect.height = Math.round( nRect.height );\n        \n        // Draw the brush.\n        let canvas = ref.current,\n            g = canvas.getContext( \"2d\" );\n        g.strokeStyle = \"#99bbdd\";\n        g.fillStyle = \"#99bbdd\";\n        g.strokeRect( nRect.x, nRect.y, nRect.width, nRect.height );\n        \n        // If the handles can be used, draw them.\n        if( Matrix.isWithin && ( nRect.width >= size ) && ( nRect.height >= size )) {\n            g.fillRect( nRect.x +                      1, nRect.y +                       1, size, size );\n            g.fillRect( nRect.x + nRect.width - size - 1, nRect.y +                       1, size, size );\n            g.fillRect( nRect.x +                      1, nRect.y + nRect.height - size - 1, size, size );\n            g.fillRect( nRect.x + nRect.width - size - 1, nRect.y + nRect.height - size - 1, size, size );\n        }\n    }\n};\n\nexport default Matrix;\n","import React, { useState } from 'react';\nimport { Slider } from '@material-ui/core';\nimport Matrix from './Matrix';\nimport './App.css';\n\n// Application:  Persistent Brushing\nconst App = () => {\n    \n    // Create state.\n    const nDataDefault = 12;\n    const [ nData, setNData ] = useState( App.getPower( nDataDefault ));\n    const [ opacity, setOpacity ] = useState( 0.5 );\n    \n    // Return the component.\n    return (\n        <div className=\"Column\">\n            <div className=\"Description\">\n                <h1>Persistent Brushing</h1>\n                <p>\n                Brushing is a basic technique of exploratory data analysis, developed in the 1970s (<a href=\"https://www.researchgate.net/publication/245345268_An_interactive_multidimensional_data_display_and_analysis_system\">Fishkeller, Friedman, and Tukey</a>) and 1980s (<a href=\"https://www.jstor.org/stable/1269768?seq=1\">Becker and Cleveland</a>; <a href=\"https://www.jstor.org/stable/2289448?seq=1\">Stuetzle</a>).  Back then, analysts were happy to brush a few hundred points.  On modern hardware, we can brush a million.\n                </p>\n                <p>\n                Drag the brush to select the points.  Drag the corners to resize the brush.  Drag a rectangle in any plot to create a new brush.\n                </p>\n            </div>\n            <div className=\"GridPlots\">\n                <Matrix nData={nData} opacity={opacity} />\n            </div>\n            <div className=\"GridControls\">\n                <label>Points:</label>\n                <Slider defaultValue={ nDataDefault } step={ 1 } min={ 6 } max={ 18 }\n                    valueLabelDisplay=\"auto\" marks valueLabelFormat={( value ) => App.getPower( value ).toExponential()}\n                    onChangeCommitted={( event, value ) => { Matrix.clear(); setNData( App.getPower( value )); }} />\n                <label>Transparency:</label>\n                <Slider defaultValue={ 0.5 } step={ 0.01 } min={ 0 } max={ 1 }\n                    valueLabelDisplay=\"auto\"\n                    onChangeCommitted={( event, value ) => { Matrix.clear(); setOpacity( 1 - value ); }} />\n            </div>\n            <div className=\"Description\">\n                <h2>About this Design</h2>\n                <p>\n                This is an implementation of <a href=\"http://www.sci.utah.edu/~kpotter/Library/Papers/becker:1987:BS/index.html\">Becker and Cleveland's scatter plot matrix</a>.  To minimize distraction, the plots display no axes, but only the range of the data.  The purpose of this graph is not to show precise locations of points, but to help discover patterns, especially two-dimensional relationships in the data.\n                </p>\n                <p>\n                To optimize performance, CANVAS is used instead of SVG, and bitmap images are cached of the deselected points.  Thus drawing a plot requires only bit-blitting an image, then highlighting the selected points.  Iteration is done over a list of selected points, rather than the entire data set.\n                </p>\n                <p>\n                Some brushing implementations increase the size of selected points.  Increased size increases overplotting, so it's better to use color.\n                </p>\n                <p>\n                Colors are chosen to emphasize the data.  Black on white gives maximum emphasis.  The red selection color draws attention.  The grid, being less important, is gray.  For the same reason, the brush could be drawn in gray; however, blue is the default selection color in most web browsers.\n                </p>\n                <p>\n                Affordances are visible.  The user can see the handles to resize the brush.  This eases the learning curve for novice users.\n                </p>\n                <p>\n                To minimize distraction from the data display, handles are displayed only when they can be used.\n                </p>\n                <p>\n                The brush is <em>persistent</em> rather than <em>transient</em>.  A persistent brush reduces errors by giving the user repeated chances to adjust the brush size.  Also, a persistent brush supports sharing the result of data exploration.\n                </p>\n            </div>\n            <a href=\"https://github.com/hemanrobinson/brush/\">Code Shared on GitHub</a>\n        </div>\n    );\n}\n\n/**\n * Returns \"nice\" power of ten:  rounded to 1, 2, 5, 10, 20, 50, etc.\n *\n * @param  {number}  exp  exponent\n * @return {number}  \"nice\" power of ten:  rounded to 1, 2, 5, 10, 20, 50, etc.\n */\nApp.getPower = ( exp ) => {\n    let m = (( exp % 3 ) === 0 ) ? 1 : (( exp % 3 ) === 1 ) ? 2 : 5;\n    return m * ( 10 ** Math.floor( exp / 3 ));\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n// Render the app.\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById( 'root' )\n);\n"],"sourceRoot":""}