{"version":3,"sources":["Data.js","Axis.js","Plot.js","Matrix.js","App.js","index.js"],"names":["Data","props","isSelected","deselectAll","fill","getColumnNames","getDomain","nData","i","values","getValues","length","f","d3","x","y","Math","log","Axis","draw","width","height","canvas","index","g","getContext","columnNames","fillStyle","fontSize","s","fillText","measureText","slice","Plot","padding","normalize","rect","nx","ny","nw","nh","isWithin","point","tol","nRect","undefined","j","opacity","imageData","selectedRows","data","xScale","domain","range","yScale","deselectedImageData","d","createImageData","forEach","datum","xScaled","yScaled","k","floor","round","myImageData","set","row","putImageData","select","brush","xMin","invert","min","xMax","max","yMin","yMax","push","Matrix","ref","useRef","nColumns","totalWidth","totalHeight","useEffect","svg","current","childNodes","selectAll","remove","cell","append","join","attr","extent","on","event","sourceEvent","target","parentNode","brushNode","call","move","selection","offsetX","offsetY","xDown","yDown","xUp","yUp","node","firstChild","bitmaps","clear","clearRect","strokeStyle","moveTo","lineTo","stroke","isFirstDraw","App","useState","getPower","setNData","setOpacity","className","Slider","defaultValue","step","valueLabelDisplay","marks","valueLabelFormat","value","onChangeCommitted","href","exp","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.c4b4a36a.chunk.js","sourcesContent":["import * as d3 from 'd3';\n\n/**\n * Data sets.\n *\n * @param  {Object}  props  properties\n * @return component\n */\nconst Data = ( props ) => {\n};\n\n/**\n * True iff data row is selected.\n *\n * @type {boolean[]}\n */\nData.isSelected = [];\n\n/**\n * Deselects all rows.\n */\nData.deselectAll = () => {\n    Data.isSelected.fill( false );\n};\n\n/**\n * Returns column names.\n *\n * @return {string[]}  column names\n */\nData.getColumnNames = () => {\n    return [ \"isSelected\", \"A\", \"B\", \"A * B\", \"Math.log( 2 + A + B )\"];\n};\n\n/**\n * Returns domain of specified column.\n *\n * @param  {number}    nData  number of data values\n * @param  {number}    index  column index\n * @return {number[]}  domain of specified column\n */\nData.getDomain = ( nData, i ) => {\n//  return [ d3.min( Data.getValues( nData ), d => d[ index ]), d3.max( Data.getValues( nData ), d => d[ index ])];\n    return [ -1.5, 1.5 ];   // consistently spreads the data\n};\n\n/**\n * Data values.\n *\n * @type {number[]}\n */\nData.values = [];\n\n/**\n * Returns data values.\n *\n * @param  {number}  nData  number of data values\n * @return {Array[]}  data values by row\n */\nData.getValues = ( nData ) => {\n    if( Data.values.length !== nData ) {\n        let f = d3.randomNormal( 0, 0.5 );\n        Data.values = [];\n        for( let i = 0; ( i < nData ); i++ ) {\n            let x = f(), y = f();\n            Data.values[ i ] = [ false, x, y, x * y, Math.log( 2 + x + y )];\n        }\n    }\n    return Data.values;\n};\n\nexport default Data;\n","import Data from './Data';\n\n/**\n * Axis for scatter plot matrix in an SVG element.\n *\n * @param  {Object}  props  properties\n * @return component\n */\nconst Axis = ( props ) => {\n};\n\n/**\n * Draws the axis.\n *\n * @param  {number}  x        X coordinate, in pixels\n * @param  {number}  y        Y coordinate, in pixels\n * @param  {number}  width    width, in pixels\n * @param  {number}  height   height, in pixels\n * @param  {Element} canvas   CANVAS element\n * @param  {number}  nData    number of data values\n * @param  {number}  index    column index\n */\nAxis.draw = ( x, y, width, height, canvas, nData, index ) => {\n    \n    // Initialization.\n    let g = canvas.getContext( \"2d\" ),\n        columnNames = Data.getColumnNames();\n        \n    // Draw the column label.\n    g.fillStyle = \"#000000\";\n    g.fontSize = \"14px\";\n    let s = columnNames[ index ];\n    g.fillText( s, x + width / 2 - g.measureText( s ).width / 2, y + height - height / 2 + 4 );\n    \n    // Draw the minimum and maximum.\n    g.fontSize = \"10px\";\n    s = ( \"\" + Data.getDomain( nData, index )[ 0 ]).slice( 0, 4 );\n    g.fillText( s, x + 4, y + height - 4 );\n    s = ( \"\" + Data.getDomain( nData, index )[ 1 ]).slice( 0, 3 );\n    g.fillText( s, x + width - 3 - g.measureText( s ).width, y + 12 );\n};\n\nexport default Axis;\n","import * as d3 from 'd3';\nimport Data from './Data';\n\n/**\n * Scatter plot in an SVG element.\n *\n * @param  {Object}  props  properties\n * @return component\n */\nconst Plot = ( props ) => {\n};\n \n/**\n * Padding, in pixels.\n *\n * @constant {number}\n */\nPlot.padding = 10;\n    \n/**\n * Returns normalized rectangle.\n *\n * @param   {Rect}  rect   rectangle\n * @return  {Rect}  normalized rectangle\n */\nPlot.normalize = ( rect ) => {\n    let nx = rect.x,\n        ny = rect.y,\n        nw = rect.width,\n        nh = rect.height;\n    if( nw < 0 ) {\n        nx += nw;\n        nw = -nw;\n    }\n    if( nh < 0 ) {\n        ny += nh;\n        nh = -nh;\n    }\n    return { x: nx, y: ny, width: nw, height: nh };\n}\n\n/**\n * Returns whether point is within rectangle, within tolerance.\n *\n * @param  {Point}   point  point\n * @param  {Rect}    rect   rectangle\n * @param  {number}  tol    tolerance, or 0 for undefined\n */\nPlot.isWithin = ( point, rect, tol ) => {\n    let nRect = Plot.normalize( rect );\n    if( tol !== undefined ) {\n        nRect.x -= tol;\n        nRect.y -= tol;\n        nRect.width += 2 * tol;\n        nRect.height += 2 * tol;\n    }\n    return ( nRect.x <= point.x ) && ( point.x < nRect.x + nRect.width  ) &&\n           ( nRect.y <= point.y ) && ( point.y < nRect.y + nRect.height );\n}\n\n/**\n * Draws the plot.\n *\n * @param  {number}               x             X coordinate, in pixels\n * @param  {number}               y             Y coordinate, in pixels\n * @param  {number}               width         width, in pixels\n * @param  {number}               height        height, in pixels\n * @param  {Element}              canvas        CANVAS element\n * @param  {number}               nData         number of data values\n * @param  {number}               i             X column index\n * @param  {number}               j             Y column index\n * @param  {number}               opacity       alpha\n * @param  {ImageData|undefined}  imageData     bitmap of deselected points, or undefined if none\n * @param  {number[]|undefined}   selectedRows  Array of indices of selected rows, or undefined if none\n * @return {ImageData}            bitmap of deselected points\n */\nPlot.draw = ( x, y, width, height, canvas, nData, i, j, opacity, imageData, selectedRows ) => {\n    \n    // Initialization.\n    const g = canvas.getContext( \"2d\" ),\n        padding = Plot.padding;\n    let data = Data.getValues( nData ),\n        xScale = d3.scaleLinear().domain( Data.getDomain( nData, i )).range([ x + padding, x + width - padding ]),\n        yScale = d3.scaleLinear().domain( Data.getDomain( nData, j )).range([ y + height - padding, y + padding ]),\n        deselectedImageData = imageData;\n        \n    // Create the deselected bitmap if necessary.\n    // For alpha blending, see e.g. https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending.\n    if( deselectedImageData === undefined ) {\n        deselectedImageData = g.createImageData( width, height );                           // black and transparent\n        const d = deselectedImageData.data;\n        data.forEach(( datum ) => {\n            let xScaled = xScale( datum[ i ]) - x,\n                yScaled = yScale( datum[ j ]) - y;\n            if(( 0 <= xScaled ) && ( xScaled < width ) && ( 0 <= yScaled ) && ( yScaled < height )) {\n                let k = Math.floor( yScaled ) * ( width * 4 ) + Math.floor( xScaled ) * 4;\n                d[ k     ] = Math.round(             0 + d[ k     ] * ( 1 - opacity ));     // r\n                d[ k + 1 ] = Math.round(             0 + d[ k + 1 ] * ( 1 - opacity ));     // g\n                d[ k + 2 ] = Math.round(             0 + d[ k + 2 ] * ( 1 - opacity ));     // b\n                d[ k + 3 ] = Math.round( 255 * opacity + d[ k + 3 ] * ( 1 - opacity ));     // alpha\n            }\n        });\n    }\n    \n    // Make a local copy.\n    let myImageData = g.createImageData( width, height );\n    myImageData.data.set( deselectedImageData.data );\n    const d = myImageData.data;\n    \n    // Selected rows use opacity, but not alpha blending, in order to keep them bright.  TODO:  Explore alternatives to this.\n    // Add the selected rows as specified...\n    if( selectedRows !== undefined ) {\n        selectedRows.forEach(( row ) => {\n            let xScaled = xScale( data[ row ][ i ]) - x,\n                yScaled = yScale( data[ row ][ j ]) - y;\n            if(( 0 <= xScaled ) && ( xScaled < width ) && ( 0 <= yScaled ) && ( yScaled < height )) {\n                let k = Math.floor( yScaled ) * ( width * 4 ) + Math.floor( xScaled ) * 4;\n                d[ k ] = Math.round( 255 + d[ k ] * ( 1 - opacity ));                       // r\n            }\n        });\n    }\n    \n    // ...or add the selected rows from the data.\n    else {\n        let row = 0;\n        data.forEach(( datum ) => {\n            if( Data.isSelected[ row ]) {\n                let xScaled = xScale( datum[ i ]) - x,\n                    yScaled = yScale( datum[ j ]) - y;\n                if(( 0 <= xScaled ) && ( xScaled < width ) && ( 0 <= yScaled ) && ( yScaled < height )) {\n                    let k = Math.floor( yScaled ) * ( width * 4 ) + Math.floor( xScaled ) * 4;\n                    d[ k ] = Math.round( 255 + d[ k ] * ( 1 - opacity ));                   // r\n                }\n            }\n            row++;\n        });\n    }\n    \n    // Draw and return the bitmap.\n    g.putImageData( myImageData, x, y, padding, padding, width - 2 * padding, height - 2 * padding );\n    return deselectedImageData;\n};\n\n/**\n * Selects rows within the brush and returns them.\n *\n * @param  {number}    x       X coordinate, in pixels\n * @param  {number}    y       Y coordinate, in pixels\n * @param  {number}    width   width, in pixels\n * @param  {number}    height  height, in pixels\n * @param  {number}    nData   number of data values\n * @param  {number}    i       X column index\n * @param  {number}    j       Y column index\n * @param  {Rect}      brush   brush\n * @return {number[]}  Array of indices of selected rows, or undefined if none\n */\nPlot.select = ( x, y, width, height, nData, i, j, brush ) => {\n    \n    // Initialization.\n    const padding = Plot.padding;\n    let selectedRows = [],\n        data = Data.getValues( nData ),\n        xScale = d3.scaleLinear().domain( Data.getDomain( nData, i )).range([ x + padding, x + width - padding ]),\n        yScale = d3.scaleLinear().domain( Data.getDomain( nData, j )).range([ y + height - padding, y + padding ]),\n        xMin = xScale.invert( Math.min( brush.x, brush.x + brush.width )),\n        xMax = xScale.invert( Math.max( brush.x, brush.x + brush.width )),\n        yMin = yScale.invert( Math.max( brush.y, brush.y + brush.height )),\n        yMax = yScale.invert( Math.min( brush.y, brush.y + brush.height ));\n    \n    // Select the rows and return them.\n    let row = 0;\n    data.forEach(( datum ) => {\n        Data.isSelected[ row ] = ( xMin <= datum[ i ]) && ( datum[ i ] < xMax ) && ( yMin <= datum[ j ]) && ( datum[ j ] < yMax );\n        if( Data.isSelected[ row ]) {\n            selectedRows.push( row );\n        }\n        row++;\n    });\n    return selectedRows;\n};\n\nexport default Plot;\n","import React, { useRef, useEffect }  from 'react';\nimport * as d3 from 'd3';\nimport Data from './Data';\nimport Axis from './Axis';\nimport Plot from './Plot';\nimport './Matrix.css';\n\n/**\n * @typedef  Point  point\n *\n * @type  {object}\n * @property  {number}   x        X coordinate, in pixels\n * @property  {number}   y        Y coordinate, in pixels\n */\n\n/**\n * @typedef  Rect  rectangle\n *\n * @type  {object}\n * @property  {number}   x        X coordinate, in pixels\n * @property  {number}   y        Y coordinate, in pixels\n * @property  {number}   width    width, in pixels\n * @property  {number}   height   height, in pixels\n */\n\n/**\n * Scatter plot matrix in an SVG element.\n *\n * @param  {Object}  props  properties\n * @return component\n */\nconst Matrix = ( props ) => {\n    \n    // Initialization.\n    const ref = useRef(),\n        { nData, opacity } = props,\n        width = 200,\n        height = 200,\n        nColumns = Data.getColumnNames().length,\n        totalWidth = ( nColumns - 1 ) * width,\n        totalHeight = ( nColumns - 1 ) * height;\n    \n    // Set hook to select and draw on mounting.\n    useEffect(() => {\n        \n        // Create the matrix (after https://observablehq.com/@d3/brushable-scatterplot-matrix?collection=@d3/d3-brush).\n        const svg = d3.select( ref.current.childNodes[ 1 ]);\n        svg.selectAll( \"*\" ).remove();\n        const cell = svg.append( \"g\" )\n            .selectAll( \"g\" )\n            .data( d3.cross(d3.range( nColumns - 1 ), d3.range( nColumns - 1 )))\n            .join( \"g\" )\n            .attr( \"transform\", ([ i, j ]) => `translate(${ i * width },${ j * height })` );\n            \n        // Create the brush.\n        const onStart = ( event ) => {\n            if( !event.sourceEvent ) {\n                return;\n            }\n            const target = event.sourceEvent.target.parentNode;\n            if( Matrix.brushNode !== target ) {\n                d3.select( Matrix.brushNode ).call( brush.move, null );\n                Matrix.brushNode = target;\n            }\n            Matrix.selectedRows = [];\n            Data.deselectAll();\n        };\n        const onBrush = ( event ) => {\n            Matrix.selectedRows = [];\n            Data.deselectAll();\n            if( event.selection ) {\n                let offsetX = event.sourceEvent ? event.sourceEvent.offsetX : 400,\n                    offsetY = event.sourceEvent ? event.sourceEvent.offsetY : 200,\n                    xDown = event.selection[ 0 ][ 0 ],\n                    yDown = event.selection[ 0 ][ 1 ],\n                    xUp = event.selection[ 1 ][ 0 ],\n                    yUp = event.selection[ 1 ][ 1 ],\n                    i = Math.floor( offsetX / width ),\n                    j = Math.floor( offsetY / height ),\n                    x = i * width,\n                    y = j * height;\n                Matrix.selectedRows = ( i === j ) ? [] : Plot.select( x, y, width, height, nData, i + 1, j + 1, { x: x + xDown, y: y + yDown, width: xUp - xDown, height: yUp - yDown });\n            }\n            Matrix.draw( width, height, ref, nData, opacity );\n        };\n        const brush = d3.brush()\n            .extent([[ 2, 2 ], [ width, height ]])\n            .on( \"start\", onStart )\n            .on( \"brush end\", onBrush );\n        cell.call( brush );\n        Matrix.brush = brush;\n        \n        // Initialize the brush.\n        Matrix.brushNode = svg.node().firstChild.childNodes[ 9 ];\n        const brushCell = d3.select( Matrix.brushNode );\n        brushCell.call( brush.move, [[ 60, 60 ], [ 100, 100 ]]);\n    });\n    \n    // Return the component.\n    return <div ref={ref}><canvas width={totalWidth} height={totalHeight}></canvas><svg width={totalWidth} height={totalHeight}></svg></div>;\n};\n\n/**\n * Bitmaps of deselected rows, cached for optimization, or undefined if none.\n *\n * @type {ImageData[][]|undefined}\n */\nMatrix.bitmaps = undefined;\n \n/**\n * Array of indices of selected rows, cached for optimization.\n *\n * @type {number[]}\n */\nMatrix.selectedRows = [];\n \n/**\n * Brush, or undefined if none.\n *\n * @type {d3.brush|undefined}\n */\nMatrix.brush = undefined;\n \n/**\n * Node containing a brush, or undefined if none.\n *\n * @type {Node|undefined}\n */\nMatrix.brushNode = undefined;\n\n/**\n * Clears data structures.\n */\nMatrix.clear = () => {\n    Data.deselectAll();\n    Matrix.bitmaps = undefined;\n    Matrix.selectedRows = [];\n    if( Matrix.brushNode && Matrix.brush ) {\n        d3.select( Matrix.brushNode ).call( Matrix.brush.move, null );\n        Matrix.brushNode = undefined;\n    }\n};\n\n/**\n * Draws the plots.\n *\n * @param  {number}  width    width in pixels\n * @param  {number}  height   height in pixels\n * @param  {Object}  ref      reference to DIV\n * @param  {number}  nData    number of data values\n * @param  {number}  opacity  alpha\n */\nMatrix.draw = ( width, height, ref, nData, opacity ) => {\n    \n    // Initialization.  If no context, do nothing.\n    if( !ref ) {\n        return;\n    }\n    let canvas = ref.current.firstChild,\n        g = canvas.getContext( \"2d\" ),\n        nColumns = Data.getColumnNames().length;\n    if( !g ) {\n        return;\n    }\n    \n    // Erase the drawing area.\n    g.clearRect( 0, 0, ( nColumns - 1 ) * width, ( nColumns - 1 ) * height );\n    \n    // Draw the grid.\n    g.strokeStyle = \"#939ba1\";\n    for( let i = 1; ( i < nColumns - 1 ); i++ ) {\n        g.moveTo( i * width + 0.5, 0 );\n        g.lineTo( i * width + 0.5, ( nColumns - 1 ) * height );\n        g.moveTo( 0, i * height + 0.5 );\n        g.lineTo(( nColumns - 1 ) * width, i * height + 0.5 );\n    }\n    g.stroke();\n    \n    // Draw the plots and the axes.  On first draw, store the bitmaps.\n    let isFirstDraw = !Matrix.bitmaps;\n    if( isFirstDraw ) {\n        Matrix.bitmaps = [];\n    }\n    for( let i = 1; ( i < nColumns ); i++ ) {\n        for( let j = 1; ( j < nColumns ); j++ ) {\n\n            // Get the position.\n            let x = ( i - 1 ) * width,\n                y = ( j - 1 ) * height;\n\n            // Draw an axis...\n            if( i === j ) {\n                Axis.draw( x, y, width, height, canvas, nData, i );\n            }\n\n            // ...or a plot.\n            else {\n                if( isFirstDraw ) {\n                    if( Matrix.bitmaps[ i - 1 ] === undefined ) {\n                        Matrix.bitmaps[ i - 1 ] = [];\n                    }\n                    Matrix.bitmaps[ i - 1 ][ j - 1 ] =\n                        Plot.draw( x, y, width, height, canvas, nData, i, j, opacity, undefined, Matrix.selectedRows );\n                } else {\n                    Plot.draw( x, y, width, height, canvas, nData, i, j, opacity, Matrix.bitmaps[ i - 1 ][ j - 1 ], Matrix.selectedRows );\n                }\n            }\n        }\n    }\n};\n\nexport default Matrix;\n","import React, { useState } from 'react';\nimport { Slider } from '@material-ui/core';\nimport Matrix from './Matrix';\nimport './App.css';\n\n// Application:  Optimized Brushing\nconst App = () => {\n    \n    // Create state.\n    const nDataDefault = 12;\n    const [ nData, setNData ] = useState( App.getPower( nDataDefault ));\n    const [ opacity, setOpacity ] = useState( 0.5 );\n    \n    // Return the component.\n    return (\n        <div className=\"Column\">\n            <div className=\"Description\">\n                <h1>Optimized Brushing</h1>\n                <p>\n                Brushing is a basic technique of exploratory data analysis, developed in the 1970s and 1980s (Fishkeller, Friedman, and Tukey, 1974) (Becker and Cleveland, 1987) (Stuetzle, 1987).  Back then, analysts were happy to brush a few hundred points.  On modern hardware, we can brush many more.\n                </p>\n                <p>\n                Drag the brush to select the points.  Drag the edges to resize the brush.  Drag a rectangle in any plot to create a new brush.  Use the sliders to adjust the number of points and their transparency.\n                </p>\n                <Matrix nData={nData} opacity={opacity} />\n                <br />\n            </div>\n            <div className=\"GridControls\">\n                <label>Points per Plot:</label>\n                <Slider defaultValue={ nDataDefault } step={ 1 } min={ 6 } max={ 15 }\n                    valueLabelDisplay=\"auto\" marks valueLabelFormat={( value ) => { let s = App.getPower( value ); if( s >= 10000 ) s = s / 1000 + \"K\"; return s }}\n                    onChangeCommitted={( event, value ) => { Matrix.clear(); setNData( App.getPower( value )); }} />\n                <label>Transparency:</label>\n                <Slider defaultValue={ 0.5 } step={ 0.01 } min={ 0 } max={ 0.99 }\n                    valueLabelDisplay=\"auto\"\n                    onChangeCommitted={( event, value ) => { Matrix.clear(); setOpacity( 1 - value ); }} />\n            </div>\n            <div className=\"Description\">\n                <h2>Design Notes</h2>\n                <p>\n                Parts of this implementation derive from the examples in <a href=\"https://observablehq.com/collection/@d3/d3-brush\">the d3-brush collection</a>.\n                </p>\n                <p>\n                This design derives from <a href=\"http://www.sci.utah.edu/~kpotter/Library/Papers/becker:1987:BS/index.html\">Becker and Cleveland's scatter plot matrix</a> (Becker and Cleveland, 1987).  To minimize distraction, the matrix displays no axes, but only data ranges.  The goal is not to show precise locations of points, but to explore patterns in the data.\n                </p>\n                <p>\n                For large data sets, transparency shows density (Wegman and Luo, 2002).  This gives the scatter plots much of the functionality of contour plots, while still displaying individual points.\n                </p>\n                <p>\n                In d3's implementation, the brush is <em>persistent</em> rather than <em>transient</em>.  A persistent brush reduces errors, by enabling the user to resize the brush (Tidwell, 2010).  A persistent brush also helps users share the paths of their explorations, e.g. through screen shots.\n                </p>\n                <p>\n                Colors are chosen to emphasize the data.  Black on white gives maximum emphasis.  The red selection color draws attention.  The grid, being less important, is gray.\n                </p>\n                <p>\n                Usability tests suggested that the brush should be blue, the standard selection color (Ho, 2016).  Following standards eases the user's learning curve:  this blue object makes selections, like all the others.\n                </p>\n                <p>\n                The following optimizations improve performance:\n                </p>\n                <ol>\n                <li>CANVAS avoids the need to create many SVG objects.</li>\n                <li>Drawing is minimized by representing each data point as a single pixel, using alpha blending to show density.</li>\n                <li>Deselected points are cached in bitmaps.  So drawing a plot requires only a fast copy, then drawing the selected points.</li>\n                <li>Selected row indices are cached, so that drawing iterates over a short list, not the entire data set.</li>\n                </ol>\n                <p>\n                Performance varies, but a fast box can display 100,000 points per plot.  So a 4x4 matrix can brush 1.2 million points.\n                </p>\n                <br/>\n                <h2>References</h2>\n                <ul>\n                    <li>Becker, R. and Cleveland, W. (1987). \"Brushing Scatterplots\". Technometrics. 29 (2): 127-142. <a href=\"https://doi.org/10.2307/1269768\">https://doi.org/10.2307/1269768</a>.</li><br/>\n                    <li>Fishkeller, Friedman, and Tukey (1974). “PRIM-9: An Interactive Multidimensional Data Display and Analysis System” SLAC-PUB-1408. Stanford, CA: Stanford Linear Accelerator Center. <a href=\"https://www.researchgate.net/publication/245345268_An_interactive_multidimensional_data_display_and_analysis_system\">https://www.researchgate.net/publication/245345268_An_interactive_multidimensional_data_display_and_analysis_system</a>.</li><br/>\n                    <li>Ho, Y. (2016). Personal communication. <a href=\"https://www.linkedin.com/in/yang-ho-94b14860/\">https://www.linkedin.com/in/yang-ho-94b14860/</a></li><br/>\n                    <li>Stuetzle, W. (1987). \"Plot Windows\". Journal of the American Statistical Association. 82 (398): 466-475. <a href=\"https://doi.org/10.2307/2289448\">https://doi.org/10.2307/2289448</a>.</li><br/>\n                    <li>Tidwell, J. (2010). Designing Interfaces: Patterns for Effective Interaction Design, Second Edition, 312-314 Sebastopol CA: O'Reilly Media.<a href=\"https://www.oreilly.com/library/view/designing-interfaces-3rd/9781492051954/\">https://www.oreilly.com/library/view/designing-interfaces-3rd/9781492051954/</a>.</li><br/>\n                    <li>Wegman, E. and Luo, Q. (2002). \"On Methods of Computer Graphics for Visualizing Densities\". Journal of Computational and Graphical Statistics 11, (1), 137-162. <a href=\"https://doi.org/10.1198/106186002317375659\">https://doi.org/10.1198/106186002317375659</a>.</li><br/>\n\n                </ul>\n            </div>\n            <a href=\"https://github.com/hemanrobinson/brush/\">Code Shared on GitHub</a>\n        </div>\n    );\n}\n\n/**\n * Returns \"nice\" power of ten:  rounded to 1, 2, 5, 10, 20, 50, etc.\n *\n * @param  {number}  exp  exponent\n * @return {number}  \"nice\" power of ten:  rounded to 1, 2, 5, 10, 20, 50, etc.\n */\nApp.getPower = ( exp ) => {\n    let m = (( exp % 3 ) === 0 ) ? 1 : (( exp % 3 ) === 1 ) ? 2 : 5;\n    return m * ( 10 ** Math.floor( exp / 3 ));\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n// Render the app.\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById( 'root' )\n);\n"],"sourceRoot":""}