{"version":3,"sources":["Data.js","Axis.js","Plot.js","Matrix.js","App.js","index.js"],"names":["Data","props","isSelected","deselectAll","fill","getColumnNames","getDomain","nData","i","values","getValues","length","f","d3","x","y","Axis","draw","width","height","canvas","index","g","getContext","columnNames","fillStyle","fontSize","s","fillText","measureText","slice","Plot","padding","normalize","rect","nx","ny","nw","nh","isWithin","point","tol","nRect","undefined","j","opacity","imageData","selectedRows","data","xScale","domain","range","yScale","deselectedImageData","d","createImageData","forEach","datum","xScaled","yScaled","k","Math","floor","round","myImageData","set","row","putImageData","select","brush","xMin","invert","min","xMax","max","yMin","yMax","push","Matrix","ref","useRef","nColumns","onMouseUp","event","downLocation","useEffect","onMouseDown","onMouseMove","handleSize","isGrowing","isXMin","isYMin","isMoving","bitmaps","clear","size","halfSize","xDown","nativeEvent","offsetX","yDown","offsetY","preventDefault","isXMax","isYMax","abs","xUp","yUp","type","current","clearRect","strokeStyle","moveTo","lineTo","stroke","isFirstDraw","strokeRect","fillRect","App","useState","getPower","setNData","setOpacity","className","Slider","defaultValue","step","valueLabelDisplay","marks","valueLabelFormat","value","toExponential","onChangeCommitted","href","exp","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2828d760.chunk.js","sourcesContent":["import * as d3 from 'd3';\n\n/**\n * Data sets.\n *\n * @param  {Object}  props  properties\n * @return component\n */\nconst Data = ( props ) => {\n};\n\n/**\n * True iff data row is selected.\n *\n * @type {boolean[]}\n */\nData.isSelected = [];\n\n/**\n * Deselects all rows.\n */\nData.deselectAll = () => {\n    Data.isSelected.fill( false );\n};\n\n/**\n * Returns column names.\n *\n * @return {string[]}  column names\n */\nData.getColumnNames = () => {\n    return [ \"isSelected\", \"A\", \"B\", \"A + B\", \"A * B\" ];\n};\n\n/**\n * Returns domain of specified column.\n *\n * @param  {number}    nData  number of data values\n * @param  {number}    index  column index\n * @return {number[]}  domain of specified column\n */\nData.getDomain = ( nData, i ) => {\n//    return [ d3.min( Data.getValues( nData ), d => d[ index ]), d3.max( Data.getValues( nData ), d => d[ index ])];\n    return [ -2, 2 ];   // consistently spreads the data\n};\n\n/**\n * Data values.\n *\n * @type {number[]}\n */\nData.values = [];\n\n/**\n * Returns data values.\n *\n * @param  {number}  nData  number of data values\n * @return {Array[]}  data values by row\n */\nData.getValues = ( nData ) => {\n    if( Data.values.length !== nData ) {\n        let f = d3.randomNormal( 0, 0.5 );\n        Data.values = [];\n        for( let i = 0; ( i < nData ); i++ ) {\n            let x = f(), y = f();\n            Data.values[ i ] = [ false, x, y, x + y, x * y ];\n        }\n    }\n    return Data.values;\n};\n\nexport default Data;\n","import Data from './Data';\n\n/**\n * Axis for scatter plot matrix in an SVG element.\n *\n * @param  {Object}  props  properties\n * @return component\n */\nconst Axis = ( props ) => {\n};\n\n/**\n * Draws the axis.\n *\n * @param  {number}  x        X coordinate, in pixels\n * @param  {number}  y        Y coordinate, in pixels\n * @param  {number}  width    width, in pixels\n * @param  {number}  height   height, in pixels\n * @param  {Element} canvas   CANVAS element\n * @param  {number}  nData    number of data values\n * @param  {number}  index    column index\n */\nAxis.draw = ( x, y, width, height, canvas, nData, index ) => {\n    \n    // Initialization.\n    let g = canvas.getContext( \"2d\" ),\n        columnNames = Data.getColumnNames();\n        \n    // Draw the column label.\n    g.fillStyle = \"#000000\";\n    g.fontSize = \"14px\";\n    let s = columnNames[ index ];\n    g.fillText( s, x + width / 2 - g.measureText( s ).width / 2, y + height - height / 2 + 4 );\n    \n    // Draw the minimum and maximum.\n    g.fontSize = \"10px\";\n    s = ( \"\" + Data.getDomain( nData, index )[ 0 ]).slice( 0, 4 );\n    g.fillText( s, x + 4, y + height - 4 );\n    s = ( \"\" + Data.getDomain( nData, index )[ 1 ]).slice( 0, 3 );\n    g.fillText( s, x + width - 3 - g.measureText( s ).width, y + 12 );\n};\n\nexport default Axis;\n","import * as d3 from 'd3';\nimport Data from './Data';\n\n/**\n * Scatter plot in an SVG element.\n *\n * @param  {Object}  props  properties\n * @return component\n */\nconst Plot = ( props ) => {\n};\n \n/**\n * Padding, in pixels.\n *\n * @constant {number}\n */\nPlot.padding = 10;\n    \n/**\n * Returns normalized rectangle.\n *\n * @param   {Rect}  rect   rectangle\n * @return  {Rect}  normalized rectangle\n */\nPlot.normalize = ( rect ) => {\n    let nx = rect.x,\n        ny = rect.y,\n        nw = rect.width,\n        nh = rect.height;\n    if( nw < 0 ) {\n        nx += nw;\n        nw = -nw;\n    }\n    if( nh < 0 ) {\n        ny += nh;\n        nh = -nh;\n    }\n    return { x: nx, y: ny, width: nw, height: nh };\n}\n\n/**\n * Returns whether point is within rectangle, within tolerance.\n *\n * @param  {Point}   point  point\n * @param  {Rect}    rect   rectangle\n * @param  {number}  tol    tolerance, or 0 for undefined\n */\nPlot.isWithin = ( point, rect, tol ) => {\n    let nRect = Plot.normalize( rect );\n    if( tol !== undefined ) {\n        nRect.x -= tol;\n        nRect.y -= tol;\n        nRect.width += 2 * tol;\n        nRect.height += 2 * tol;\n    }\n    return ( nRect.x <= point.x ) && ( point.x < nRect.x + nRect.width  ) &&\n           ( nRect.y <= point.y ) && ( point.y < nRect.y + nRect.height );\n}\n\n/**\n * Draws the plot.\n *\n * @param  {number}  x            X coordinate, in pixels\n * @param  {number}               y            Y coordinate, in pixels\n * @param  {number}               width        width, in pixels\n * @param  {number}               height       height, in pixels\n * @param  {Element}              canvas       CANVAS element\n * @param  {number}               nData        number of data values\n * @param  {number}               i            X column index\n * @param  {number}               j            Y column index\n * @param  {number}               opacity      alpha\n * @param  {ImageData|undefined}  imageData     bitmap of deselected points, or undefined if none\n * @param  {number[]|undefined}   selectedRows  Array of indices of selected rows, or undefined if none\n * @return {ImageData}            bitmap of deselected points\n */\nPlot.draw = ( x, y, width, height, canvas, nData, i, j, opacity, imageData, selectedRows ) => {\n    \n    // Initialization.\n    const g = canvas.getContext( \"2d\" ),\n        padding = Plot.padding;\n    let data = Data.getValues( nData ),\n        xScale = d3.scaleLinear().domain( Data.getDomain( nData, i )).range([ x + padding, x + width - padding ]),\n        yScale = d3.scaleLinear().domain( Data.getDomain( nData, j )).range([ y + height - padding, y + padding ]),\n        deselectedImageData = imageData;\n        \n    // Create the deselected bitmap if necessary.\n    // For alpha blending, see e.g. https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending.\n    if( deselectedImageData === undefined ) {\n        deselectedImageData = g.createImageData( width, height );                           // black, transparent\n        const d = deselectedImageData.data;\n        data.forEach(( datum ) => {\n            let xScaled = xScale( datum[ i ]) - x,\n                yScaled = yScale( datum[ j ]) - y;\n            if(( 0 <= xScaled ) && ( xScaled < width ) && ( 0 <= yScaled ) && ( yScaled < height )) {\n                let k = Math.floor( yScaled ) * ( width * 4 ) + Math.floor( xScaled ) * 4;\n                d[ k     ] = Math.round(             0 + d[ k     ] * ( 1 - opacity ));     // r\n                d[ k + 1 ] = Math.round(             0 + d[ k + 1 ] * ( 1 - opacity ));     // g\n                d[ k + 2 ] = Math.round(             0 + d[ k + 2 ] * ( 1 - opacity ));     // b\n                d[ k + 3 ] = Math.round( 255 * opacity + d[ k + 3 ] * ( 1 - opacity ));     // alpha\n            }\n        });\n    }\n    \n    // Make a local copy.\n    let myImageData = g.createImageData( width, height );\n    myImageData.data.set( deselectedImageData.data );\n    const d = myImageData.data;\n    \n    // Add the selected rows as specified...\n    // TODO:  Explore alpha blending for selected rows; for now, it seems best to keep them bright.\n    if( selectedRows !== undefined ) {\n        selectedRows.forEach(( row ) => {\n            let xScaled = xScale( data[ row ][ i ]) - x,\n                yScaled = yScale( data[ row ][ j ]) - y;\n            if(( 0 <= xScaled ) && ( xScaled < width ) && ( 0 <= yScaled ) && ( yScaled < height )) {\n                let k = Math.floor( yScaled ) * ( width * 4 ) + Math.floor( xScaled ) * 4;\n                d[ k ] = Math.round( 255 + d[ k ] * ( 1 - opacity ));                       // r\n            }\n        });\n    }\n    \n    // ...or from the data.\n    else {\n        let row = 0;\n        data.forEach(( datum ) => {\n            if( Data.isSelected[ row ]) {\n                let xScaled = xScale( datum[ i ]) - x,\n                    yScaled = yScale( datum[ j ]) - y;\n                if(( 0 <= xScaled ) && ( xScaled < width ) && ( 0 <= yScaled ) && ( yScaled < height )) {\n                    let k = Math.floor( yScaled ) * ( width * 4 ) + Math.floor( xScaled ) * 4;\n                    d[ k ] = Math.round( 255 + d[ k ] * ( 1 - opacity ));                   // r\n                }\n            }\n            row++;\n        });\n    }\n    \n    // Draw and return the bitmap.\n    g.putImageData( myImageData, x, y, padding, padding, width - padding, height - padding );\n    return deselectedImageData;\n};\n\n/**\n * Selects rows.\n *\n * @param  {number}    x       X coordinate, in pixels\n * @param  {number}    y       Y coordinate, in pixels\n * @param  {number}    width   width, in pixels\n * @param  {number}    height  height, in pixels\n * @param  {number}    nData   number of data values\n * @param  {number}    i       X column index\n * @param  {number}    j       Y column index\n * @param  {Rect}      brush   brush\n * @return {number[]}  Array of indices of selected rows, or undefined if none\n */\nPlot.select = ( x, y, width, height, nData, i, j, brush ) => {\n    \n    // Initialization.\n    const padding = Plot.padding;\n    let selectedRows = [],\n        data = Data.getValues( nData ),\n        xScale = d3.scaleLinear().domain( Data.getDomain( nData, i )).range([ x + padding, x + width - padding ]),\n        yScale = d3.scaleLinear().domain( Data.getDomain( nData, j )).range([ y + height - padding, y + padding ]),\n        xMin = xScale.invert( Math.min( brush.x, brush.x + brush.width )),\n        xMax = xScale.invert( Math.max( brush.x, brush.x + brush.width )),\n        yMin = yScale.invert( Math.max( brush.y, brush.y + brush.height )),\n        yMax = yScale.invert( Math.min( brush.y, brush.y + brush.height ));\n    \n    // Select the rows and return them.\n    let row = 0;\n    data.forEach(( datum ) => {\n        Data.isSelected[ row ] = ( xMin <= datum[ i ]) && ( datum[ i ] < xMax ) && ( yMin <= datum[ j ]) && ( datum[ j ] < yMax );\n        if( Data.isSelected[ row ]) {\n            selectedRows.push( row );\n        }\n        row++;\n    });\n    return selectedRows;\n};\n\nexport default Plot;\n","import React, { useRef, useEffect }  from 'react';\nimport Data from './Data';\nimport Axis from './Axis';\nimport Plot from './Plot';\nimport './Matrix.css';\n\n/**\n * @typedef  Point  point\n *\n * @type  {object}\n * @property  {number}   x        X coordinate, in pixels\n * @property  {number}   y        Y coordinate, in pixels\n */\n\n/**\n * @typedef  Rect  rectangle\n *\n * @type  {object}\n * @property  {number}   x        X coordinate, in pixels\n * @property  {number}   y        Y coordinate, in pixels\n * @property  {number}   width    width, in pixels\n * @property  {number}   height   height, in pixels\n */\n\n/**\n * Scatter plot matrix in an SVG element.\n *\n * @param  {Object}  props  properties\n * @return component\n */\nconst Matrix = ( props ) => {\n    \n    // Initialization.\n    const width = 200, height = 200;\n    let ref = useRef(),\n        { nData, opacity } = props,\n        columnNames = Data.getColumnNames(),\n        nColumns = columnNames.length;\n    \n    // Support brushing.\n    let onMouseDown = ( event ) => {\n            Matrix.onMouseDown( event );\n        },\n            \n        // If there was a down event, handle this event.\n        onMouseUp = ( event ) => {\n            if(( Matrix.downLocation.x >= 0 ) && ( Matrix.downLocation.y >= 0 )) {\n                Matrix.onMouseUp( event, width, height, ref, nData );\n                Matrix.draw( width, height, ref, nData, opacity );\n            }\n        };\n    \n    // Set hook to draw on mounting.\n    useEffect(() => {\n        Matrix.draw( width, height, ref, nData, opacity );\n    });\n    \n    // Return the component.\n    return <canvas width={( nColumns - 1 ) * width} height={( nColumns - 1 ) * height} ref={ref} onMouseDown={onMouseDown} onMouseMove={onMouseUp} onMouseUp={onMouseUp}></canvas>;\n};\n \n/**\n * Brush handle size.\n *\n * @constant {number}\n */\nMatrix.handleSize = 2;\n \n/**\n * True iff the user is resizing the brush.\n *\n * @type {boolean}\n */\nMatrix.isGrowing = false;\n \n/**\n * True iff the user is resizing the brush with one of the minimum X handles.\n *\n * @type {boolean}\n */\nMatrix.isXMin = false;\n \n/**\n * True iff the user is resizing the brush with one of the minimum Y handles.\n *\n * @type {boolean}\n */\nMatrix.isYMin = false;\n \n/**\n * True iff the user is moving the brush.\n *\n * @type {boolean}\n */\nMatrix.isMoving = false;\n\n/**\n * Bitmaps of deselected rows, cached for optimization.\n *\n * @type {ImageData[][]|undefined}\n */\nMatrix.bitmaps = undefined;\n \n/**\n * Array of indices of selected rows, or undefined if none.\n *\n * @type {number[]|undefined}\n */\nMatrix.selectedRows = undefined;\n \n/**\n * Brush.  If no brush is defined, x and y are less than zero.\n *\n * @type {Rect}\n */\nMatrix.brush = { x: 430, y: 230, width: 30, height: 30 };\n \n/**\n * Down event location.  If no down location is defined, x and y are less than zero.\n *\n * @type {Point}\n */\nMatrix.downLocation = { x: -1, y: -1 };\n \n/**\n * Clears data structures.\n */\nMatrix.clear = () => {\n    Matrix.bitmaps = undefined;\n    Matrix.selectedRows = undefined;\n    Data.deselectAll();\n    Matrix.brush = { x: 430, y: 230, width: 30, height: 30 };\n    Matrix.downLocation = { x: -1, y: -1 };\n};\n    \n/**\n * Handles mouse down event.\n *\n * This method modifies Matrix.downLocation.\n *\n * @param  {Event}    event     event\n */\nMatrix.onMouseDown = ( event ) => {\n\n    // Initialization.\n    const size = Matrix.handleSize,\n        halfSize = size / 2,\n        tol = 2 * size;\n    let xDown = event.nativeEvent.offsetX,\n        yDown = event.nativeEvent.offsetY,\n        brush = Matrix.brush;\n        \n    // Prevent text selection.\n    event.preventDefault();\n        \n    // Reset the mousedown coordinates.\n    Matrix.downLocation.x = xDown;\n    Matrix.downLocation.y = yDown;\n    \n    // If within an existing brush, store the handle...\n    if( Plot.isWithin({ x: xDown, y: yDown }, brush, Matrix.handleSize )) {\n        let isXMin = false,\n            isXMax = false,\n            isYMin = false,\n            isYMax = false;\n        if( brush.width >= 0 ) {\n            if( Math.abs( brush.x + brush.width - halfSize - xDown ) <= tol ) {\n                isXMax = true;\n            } else if( Math.abs( brush.x + halfSize - xDown ) <= tol ) {\n                isXMin = true;\n            }\n        } else {\n            if( Math.abs( brush.x + brush.width + halfSize - xDown ) <= tol ) {\n                isXMin = true;\n            } else if( Math.abs( brush.x - halfSize - xDown ) <= tol ) {\n                isXMax = true;\n            }\n        }\n        if( brush.height >= 0 ) {\n            if( Math.abs( brush.y + brush.height - halfSize - yDown ) <= tol ) {\n                isYMin = true;\n            } else if( Math.abs( brush.y + halfSize - yDown ) <= tol ) {\n                isYMax = true;\n            }\n        } else {\n            if( Math.abs( brush.y + brush.height + halfSize - yDown ) <= tol ) {\n                isYMax = true;\n            } else if( Math.abs( brush.y - halfSize - yDown ) <= tol ) {\n                isYMin = true;\n            }\n        }\n        Matrix.isGrowing = false;\n        Matrix.isMoving = false;\n        if(( isXMin || isXMax ) && ( isYMin || isYMax )) {\n            Matrix.isGrowing = true;\n            Matrix.isXMin = isXMin;\n            Matrix.isYMin = isYMin;\n        } else {\n            Matrix.isMoving = true;\n        }\n    }\n    \n    // ...otherwise start creating a new brush.\n    else {\n        Matrix.brush.x = xDown;\n        Matrix.brush.y = yDown;\n        Matrix.brush.width = 0;\n        Matrix.brush.height = 0;\n        Matrix.isGrowing = true;\n        Matrix.isXMin = false;\n        Matrix.isYMin = true;\n        Matrix.isMoving = false;\n    }\n};\n\n/**\n * Handles mouse up event.\n *\n * This method modifies Matrix.downLocation.\n *\n * @param  {Event}   event    event\n * @param  {number}  width    width, in pixels\n * @param  {number}  height   height, in pixels\n * @param  {Object}  ref      reference to SVG element\n * @param  {number}  nData    number of data values\n */\nMatrix.onMouseUp = ( event, width, height, ref, nData ) => {\n\n    // Initialization.\n    let xDown = Matrix.downLocation.x,\n        yDown = Matrix.downLocation.y,\n        xUp = event.nativeEvent.offsetX,\n        yUp = event.nativeEvent.offsetY,\n        i = Math.floor( xDown / width ),\n        j = Math.floor( yDown / height ),\n        x = i * width,\n        y = j * height,\n        brush = Matrix.brush;\n\n    // If mouse button is not down, do nothing.\n    if(( xDown < 0 ) || ( yDown < 0 )) {\n        return;\n    }\n        \n    // If the event is on an axis, deselect on mouseup...\n    if( i === j ) {\n        if( event.type === \"mouseup\" ) {\n            Data.deselectAll();\n        }\n    }\n        \n    // ...or if the event is on a plot, handle brushing.\n    else {\n        \n        // Grow the brush...\n        if( Matrix.isGrowing ) {\n            xUp = Math.min( x + width  - 1, Math.max( x + 1, xUp ));\n            yUp = Math.min( y + height - 1, Math.max( y + 1, yUp ));\n            if( Matrix.isXMin ) {\n                brush.width -= xUp - brush.x;\n                brush.x = xUp;\n            } else {\n                brush.width = xUp - brush.x;\n            }\n            if( Matrix.isYMin ) {\n                brush.height = yUp - brush.y;\n            } else {\n                brush.height -= yUp - brush.y;\n                brush.y = yUp;\n            }\n        }\n        \n        // ...or move the brush.\n        else if( Matrix.isMoving ) {\n            brush.x += xUp - xDown;\n            brush.y += yUp - yDown;\n            Matrix.downLocation.x = xUp;\n            Matrix.downLocation.y = yUp;\n            if( brush.x < x + 1 ) {\n                brush.x = x + 1;\n            }\n            if( brush.x > x + width - 1 - brush.width ) {\n                brush.x = x + width - 1 - brush.width;\n            }\n            if( brush.y < y + 1 ) {\n                brush.y = y + 1;\n            }\n            if( brush.y > y + height - 1 - brush.height ) {\n                brush.y = y + height - 1 - brush.height;\n            }\n        }\n        \n        // Select points within the brush, and deselect all others.\n        Matrix.selectedRows = Plot.select( x, y, width, height, nData, i + 1, j + 1, brush );\n    }\n    \n    // On mouseup, clear the down location and normalize the brush.\n    if( event.type === \"mouseup\" ) {\n        Matrix.downLocation.x = -1;\n        Matrix.downLocation.y = -1;\n        Matrix.isGrowing = false;\n        Matrix.isXMin = false;\n        Matrix.isYMin = false;\n        Matrix.isMoving = false;\n        if( brush.width < 0 ) {\n            brush.x += brush.width;\n            brush.width = -brush.width;\n        }\n        if( brush.height < 0 ) {\n            brush.y += brush.height;\n            brush.height = -brush.height;\n        }\n    }\n};\n\n/**\n * Draws the plots.\n *\n * @param  {number}               width         width in pixels\n * @param  {number}               height        height in pixels\n * @param  {Array}                ref           reference to SVG element\n * @param  {number}               nData         number of data values\n * @param  {number}               opacity       alpha\n */\nMatrix.draw = ( width, height, ref, nData, opacity ) => {\n    \n    // Initialization.  If no context, do nothing.\n    let canvas = ref.current,\n        g = canvas.getContext( \"2d\" ),\n        nColumns = Data.getColumnNames().length;\n    if( !g ) {\n        return;\n    }\n    \n    // Draw the grid.\n    g.clearRect( 0, 0, ( nColumns - 1 ) * width, ( nColumns - 1 ) * height );\n    g.strokeStyle = \"#a0a0a0\";\n    for( let i = 1; ( i < nColumns - 1 ); i++ ) {\n        g.moveTo( i * width + 0.5, 0 );\n        g.lineTo( i * width + 0.5, ( nColumns - 1 ) * height );\n        g.moveTo( 0, i * height + 0.5 );\n        g.lineTo(( nColumns - 1 ) * width, i * height + 0.5 );\n    }\n    g.stroke();\n    \n    // Draw the plots and the axes.\n    let isFirstDraw = !Matrix.bitmaps;\n    if( isFirstDraw ) {\n        Matrix.bitmaps = [];\n    }\n    for( let i = 1; ( i < nColumns ); i++ ) {\n        for( let j = 1; ( j < nColumns ); j++ ) {\n\n            // Get the position.\n            let x = ( i - 1 ) * width,\n                y = ( j - 1 ) * height;\n\n            // Draw an axis...\n            if( i === j ) {\n                Axis.draw( x, y, width, height, canvas, nData, i );\n            }\n\n            // ...or a plot.\n            else {\n                if( isFirstDraw ) {\n                    if( Matrix.bitmaps[ i - 1 ] === undefined ) {\n                        Matrix.bitmaps[ i - 1 ] = [];\n                    }\n                    Matrix.bitmaps[ i - 1 ][ j - 1 ] = Plot.draw( x, y, width, height, canvas, nData, i, j, opacity );\n                } else {\n                    Plot.draw( x, y, width, height, canvas, nData, i, j, opacity, Matrix.bitmaps[ i - 1 ][ j - 1 ], Matrix.selectedRows );\n                }\n            }\n        }\n    }\n    \n    // Draw the brush.\n    let brush = Matrix.brush;\n    if(( brush.x >= 0 ) && ( brush.y >= 0 )) {\n        \n        // Normalize the brush and minimize anti-aliasing.\n        const size = Matrix.handleSize;\n        let nRect = Plot.normalize( brush );\n        nRect.x = Math.floor( nRect.x ) + 0.5;\n        nRect.y = Math.floor( nRect.y ) + 0.5;\n        nRect.width = Math.round( nRect.width );\n        nRect.height = Math.round( nRect.height );\n        \n        // Draw the brush.\n        g.strokeStyle = \"#99bbdd\";\n        g.fillStyle = \"#99bbdd\";\n        g.strokeRect( nRect.x, nRect.y, nRect.width, nRect.height );\n        g.fillRect( nRect.x +                      1, nRect.y +                       1, size, size );\n        g.fillRect( nRect.x + nRect.width - size - 1, nRect.y +                       1, size, size );\n        g.fillRect( nRect.x +                      1, nRect.y + nRect.height - size - 1, size, size );\n        g.fillRect( nRect.x + nRect.width - size - 1, nRect.y + nRect.height - size - 1, size, size );\n    }\n};\n\nexport default Matrix;\n","import React, { useState } from 'react';\nimport { Slider } from '@material-ui/core';\nimport Matrix from './Matrix';\nimport './App.css';\n\n/**\n * Scatter plot matrix.\n */\nconst App = () => {\n    \n    // Create state.\n    const nDataDefault = 12;\n    const [ nData, setNData ] = useState( App.getPower( nDataDefault ));\n    const [ opacity, setOpacity ] = useState( 0.4 );\n    \n    // Return the component.\n    return (\n        <div className=\"Column\">\n            <div className=\"GridPlots\">\n                <Matrix nData={nData} opacity={opacity} />\n            </div>\n            <div className=\"GridControls\">\n                <label>Points:</label>\n                <Slider defaultValue={ nDataDefault } step={ 1 } min={ 6 } max={ 18 }\n                    valueLabelDisplay=\"auto\" marks valueLabelFormat={( value ) => App.getPower( value ).toExponential()}\n                    onChangeCommitted={( event, value ) => { Matrix.clear(); setNData( App.getPower( value )); }} />\n                <label>Opacity:</label>\n                <Slider defaultValue={ 0.5 } step={ 0.01 } min={ 0 } max={ 1 }\n                    valueLabelDisplay=\"auto\"\n                    onChangeCommitted={( event, value ) => { Matrix.clear(); setOpacity( value ); }} />\n            </div>\n            <div className=\"Description\">\n                <p>\n                Brushing is a basic technique of exploratory data analysis, developed in the 1970s (<a href=\"https://www.researchgate.net/publication/245345268_An_interactive_multidimensional_data_display_and_analysis_system\">Fishkeller, Friedman, and Tukey</a>) and 1980s (<a href=\"https://www.jstor.org/stable/1269768?seq=1\">Becker and Cleveland</a>; <a href=\"https://www.jstor.org/stable/2289448?seq=1\">Stuetzle</a>).\n                </p>\n                <p>\n                Back then, analysts were happy to brush a few hundred points.  On modern hardware, with a fast browser, we can brush a million.\n                </p>\n            </div>\n            <a href=\"https://github.com/hemanrobinson/brush/\">Code Shared on GitHub</a>\n        </div>\n    );\n}\n\n/**\n * Returns \"nice\" power of ten:  rounded to 1, 2, 5, 10, 20, 50, etc.\n *\n * @param  {number}  exp  exponent\n * @return {number}  \"nice\" power of ten:  rounded to 1, 2, 5, 10, 20, 50, etc.\n */\nApp.getPower = ( exp ) => {\n    let m = (( exp % 3 ) === 0 ) ? 1 : (( exp % 3 ) === 1 ) ? 2 : 5;\n    return m * ( 10 ** Math.floor( exp / 3 ));\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n// Render the app.\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById( 'root' )\n);\n"],"sourceRoot":""}